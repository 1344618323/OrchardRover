// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timed_elastic_band.proto

#ifndef PROTOBUF_timed_5felastic_5fband_2eproto__INCLUDED
#define PROTOBUF_timed_5felastic_5fband_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace or_local_planner {
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class FootprintModel;
class FootprintModelDefaultTypeInternal;
extern FootprintModelDefaultTypeInternal _FootprintModel_default_instance_;
class FrameID;
class FrameIDDefaultTypeInternal;
extern FrameIDDefaultTypeInternal _FrameID_default_instance_;
class GoalTolerance;
class GoalToleranceDefaultTypeInternal;
extern GoalToleranceDefaultTypeInternal _GoalTolerance_default_instance_;
class Obstacles;
class ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class Optimization;
class OptimizationDefaultTypeInternal;
extern OptimizationDefaultTypeInternal _Optimization_default_instance_;
class Point2D;
class Point2DDefaultTypeInternal;
extern Point2DDefaultTypeInternal _Point2D_default_instance_;
class Robot;
class RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
}  // namespace or_local_planner

namespace or_local_planner {

namespace protobuf_timed_5felastic_5fband_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_timed_5felastic_5fband_2eproto

enum FootprintModel_FootprintType {
  FootprintModel_FootprintType_POINT = 0,
  FootprintModel_FootprintType_CIRCULAR = 1,
  FootprintModel_FootprintType_TWOCIRCLES = 2,
  FootprintModel_FootprintType_LINE = 3,
  FootprintModel_FootprintType_POLYGON = 4
};
bool FootprintModel_FootprintType_IsValid(int value);
const FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MIN = FootprintModel_FootprintType_POINT;
const FootprintModel_FootprintType FootprintModel_FootprintType_FootprintType_MAX = FootprintModel_FootprintType_POLYGON;
const int FootprintModel_FootprintType_FootprintType_ARRAYSIZE = FootprintModel_FootprintType_FootprintType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FootprintModel_FootprintType_descriptor();
inline const ::std::string& FootprintModel_FootprintType_Name(FootprintModel_FootprintType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FootprintModel_FootprintType_descriptor(), value);
}
inline bool FootprintModel_FootprintType_Parse(
    const ::std::string& name, FootprintModel_FootprintType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FootprintModel_FootprintType>(
    FootprintModel_FootprintType_descriptor(), name, value);
}
// ===================================================================

class FrameID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.FrameID) */ {
 public:
  FrameID();
  virtual ~FrameID();

  FrameID(const FrameID& from);

  inline FrameID& operator=(const FrameID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameID(FrameID&& from) noexcept
    : FrameID() {
    *this = ::std::move(from);
  }

  inline FrameID& operator=(FrameID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameID& default_instance();

  static inline const FrameID* internal_default_instance() {
    return reinterpret_cast<const FrameID*>(
               &_FrameID_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(FrameID* other);
  friend void swap(FrameID& a, FrameID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameID* New() const PROTOBUF_FINAL { return New(NULL); }

  FrameID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FrameID& from);
  void MergeFrom(const FrameID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FrameID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string odom_frame = 1;
  bool has_odom_frame() const;
  void clear_odom_frame();
  static const int kOdomFrameFieldNumber = 1;
  const ::std::string& odom_frame() const;
  void set_odom_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_odom_frame(::std::string&& value);
  #endif
  void set_odom_frame(const char* value);
  void set_odom_frame(const char* value, size_t size);
  ::std::string* mutable_odom_frame();
  ::std::string* release_odom_frame();
  void set_allocated_odom_frame(::std::string* odom_frame);

  // optional string map_frame = 2;
  bool has_map_frame() const;
  void clear_map_frame();
  static const int kMapFrameFieldNumber = 2;
  const ::std::string& map_frame() const;
  void set_map_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_map_frame(::std::string&& value);
  #endif
  void set_map_frame(const char* value);
  void set_map_frame(const char* value, size_t size);
  ::std::string* mutable_map_frame();
  ::std::string* release_map_frame();
  void set_allocated_map_frame(::std::string* map_frame);

  // @@protoc_insertion_point(class_scope:or_local_planner.FrameID)
 private:
  void set_has_odom_frame();
  void clear_has_odom_frame();
  void set_has_map_frame();
  void clear_has_map_frame();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr odom_frame_;
  ::google::protobuf::internal::ArenaStringPtr map_frame_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.Point2D) */ {
 public:
  Point2D();
  virtual ~Point2D();

  Point2D(const Point2D& from);

  inline Point2D& operator=(const Point2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point2D(Point2D&& from) noexcept
    : Point2D() {
    *this = ::std::move(from);
  }

  inline Point2D& operator=(Point2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2D& default_instance();

  static inline const Point2D* internal_default_instance() {
    return reinterpret_cast<const Point2D*>(
               &_Point2D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Point2D* other);
  friend void swap(Point2D& a, Point2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point2D* New() const PROTOBUF_FINAL { return New(NULL); }

  Point2D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point2D& from);
  void MergeFrom(const Point2D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:or_local_planner.Point2D)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Trajectory* other);
  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const PROTOBUF_FINAL { return New(NULL); }

  Trajectory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float dt_ref = 2;
  bool has_dt_ref() const;
  void clear_dt_ref();
  static const int kDtRefFieldNumber = 2;
  float dt_ref() const;
  void set_dt_ref(float value);

  // optional float dt_hysteresis = 3;
  bool has_dt_hysteresis() const;
  void clear_dt_hysteresis();
  static const int kDtHysteresisFieldNumber = 3;
  float dt_hysteresis() const;
  void set_dt_hysteresis(float value);

  // optional bool teb_autosize = 1;
  bool has_teb_autosize() const;
  void clear_teb_autosize();
  static const int kTebAutosizeFieldNumber = 1;
  bool teb_autosize() const;
  void set_teb_autosize(bool value);

  // optional bool global_plan_overwrite_orientation = 4;
  bool has_global_plan_overwrite_orientation() const;
  void clear_global_plan_overwrite_orientation();
  static const int kGlobalPlanOverwriteOrientationFieldNumber = 4;
  bool global_plan_overwrite_orientation() const;
  void set_global_plan_overwrite_orientation(bool value);

  // optional bool allow_init_with_backwards_motion = 5;
  bool has_allow_init_with_backwards_motion() const;
  void clear_allow_init_with_backwards_motion();
  static const int kAllowInitWithBackwardsMotionFieldNumber = 5;
  bool allow_init_with_backwards_motion() const;
  void set_allow_init_with_backwards_motion(bool value);

  // optional bool via_points_ordered = 7;
  bool has_via_points_ordered() const;
  void clear_via_points_ordered();
  static const int kViaPointsOrderedFieldNumber = 7;
  bool via_points_ordered() const;
  void set_via_points_ordered(bool value);

  // optional float global_plan_viapoint_sep = 6;
  bool has_global_plan_viapoint_sep() const;
  void clear_global_plan_viapoint_sep();
  static const int kGlobalPlanViapointSepFieldNumber = 6;
  float global_plan_viapoint_sep() const;
  void set_global_plan_viapoint_sep(float value);

  // optional float max_global_plan_lookahead_dist = 8;
  bool has_max_global_plan_lookahead_dist() const;
  void clear_max_global_plan_lookahead_dist();
  static const int kMaxGlobalPlanLookaheadDistFieldNumber = 8;
  float max_global_plan_lookahead_dist() const;
  void set_max_global_plan_lookahead_dist(float value);

  // optional float force_reinit_new_goal_dist = 10;
  bool has_force_reinit_new_goal_dist() const;
  void clear_force_reinit_new_goal_dist();
  static const int kForceReinitNewGoalDistFieldNumber = 10;
  float force_reinit_new_goal_dist() const;
  void set_force_reinit_new_goal_dist(float value);

  // optional int64 feasibility_check_no_poses = 11;
  bool has_feasibility_check_no_poses() const;
  void clear_feasibility_check_no_poses();
  static const int kFeasibilityCheckNoPosesFieldNumber = 11;
  ::google::protobuf::int64 feasibility_check_no_poses() const;
  void set_feasibility_check_no_poses(::google::protobuf::int64 value);

  // optional int64 min_samples = 13;
  bool has_min_samples() const;
  void clear_min_samples();
  static const int kMinSamplesFieldNumber = 13;
  ::google::protobuf::int64 min_samples() const;
  void set_min_samples(::google::protobuf::int64 value);

  // optional int64 max_samples = 14;
  bool has_max_samples() const;
  void clear_max_samples();
  static const int kMaxSamplesFieldNumber = 14;
  ::google::protobuf::int64 max_samples() const;
  void set_max_samples(::google::protobuf::int64 value);

  // optional bool exact_arc_length = 9;
  bool has_exact_arc_length() const;
  void clear_exact_arc_length();
  static const int kExactArcLengthFieldNumber = 9;
  bool exact_arc_length() const;
  void set_exact_arc_length(bool value);

  // optional bool publish_feedback = 12;
  bool has_publish_feedback() const;
  void clear_publish_feedback();
  static const int kPublishFeedbackFieldNumber = 12;
  bool publish_feedback() const;
  void set_publish_feedback(bool value);

  // @@protoc_insertion_point(class_scope:or_local_planner.Trajectory)
 private:
  void set_has_teb_autosize();
  void clear_has_teb_autosize();
  void set_has_dt_ref();
  void clear_has_dt_ref();
  void set_has_dt_hysteresis();
  void clear_has_dt_hysteresis();
  void set_has_global_plan_overwrite_orientation();
  void clear_has_global_plan_overwrite_orientation();
  void set_has_allow_init_with_backwards_motion();
  void clear_has_allow_init_with_backwards_motion();
  void set_has_global_plan_viapoint_sep();
  void clear_has_global_plan_viapoint_sep();
  void set_has_via_points_ordered();
  void clear_has_via_points_ordered();
  void set_has_max_global_plan_lookahead_dist();
  void clear_has_max_global_plan_lookahead_dist();
  void set_has_exact_arc_length();
  void clear_has_exact_arc_length();
  void set_has_force_reinit_new_goal_dist();
  void clear_has_force_reinit_new_goal_dist();
  void set_has_feasibility_check_no_poses();
  void clear_has_feasibility_check_no_poses();
  void set_has_publish_feedback();
  void clear_has_publish_feedback();
  void set_has_min_samples();
  void clear_has_min_samples();
  void set_has_max_samples();
  void clear_has_max_samples();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float dt_ref_;
  float dt_hysteresis_;
  bool teb_autosize_;
  bool global_plan_overwrite_orientation_;
  bool allow_init_with_backwards_motion_;
  bool via_points_ordered_;
  float global_plan_viapoint_sep_;
  float max_global_plan_lookahead_dist_;
  float force_reinit_new_goal_dist_;
  ::google::protobuf::int64 feasibility_check_no_poses_;
  ::google::protobuf::int64 min_samples_;
  ::google::protobuf::int64 max_samples_;
  bool exact_arc_length_;
  bool publish_feedback_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FootprintModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.FootprintModel) */ {
 public:
  FootprintModel();
  virtual ~FootprintModel();

  FootprintModel(const FootprintModel& from);

  inline FootprintModel& operator=(const FootprintModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FootprintModel(FootprintModel&& from) noexcept
    : FootprintModel() {
    *this = ::std::move(from);
  }

  inline FootprintModel& operator=(FootprintModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FootprintModel& default_instance();

  static inline const FootprintModel* internal_default_instance() {
    return reinterpret_cast<const FootprintModel*>(
               &_FootprintModel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FootprintModel* other);
  friend void swap(FootprintModel& a, FootprintModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FootprintModel* New() const PROTOBUF_FINAL { return New(NULL); }

  FootprintModel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FootprintModel& from);
  void MergeFrom(const FootprintModel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FootprintModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FootprintModel_FootprintType FootprintType;
  static const FootprintType POINT =
    FootprintModel_FootprintType_POINT;
  static const FootprintType CIRCULAR =
    FootprintModel_FootprintType_CIRCULAR;
  static const FootprintType TWOCIRCLES =
    FootprintModel_FootprintType_TWOCIRCLES;
  static const FootprintType LINE =
    FootprintModel_FootprintType_LINE;
  static const FootprintType POLYGON =
    FootprintModel_FootprintType_POLYGON;
  static inline bool FootprintType_IsValid(int value) {
    return FootprintModel_FootprintType_IsValid(value);
  }
  static const FootprintType FootprintType_MIN =
    FootprintModel_FootprintType_FootprintType_MIN;
  static const FootprintType FootprintType_MAX =
    FootprintModel_FootprintType_FootprintType_MAX;
  static const int FootprintType_ARRAYSIZE =
    FootprintModel_FootprintType_FootprintType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FootprintType_descriptor() {
    return FootprintModel_FootprintType_descriptor();
  }
  static inline const ::std::string& FootprintType_Name(FootprintType value) {
    return FootprintModel_FootprintType_Name(value);
  }
  static inline bool FootprintType_Parse(const ::std::string& name,
      FootprintType* value) {
    return FootprintModel_FootprintType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .or_local_planner.Point2D robot_vertices = 7;
  int robot_vertices_size() const;
  void clear_robot_vertices();
  static const int kRobotVerticesFieldNumber = 7;
  const ::or_local_planner::Point2D& robot_vertices(int index) const;
  ::or_local_planner::Point2D* mutable_robot_vertices(int index);
  ::or_local_planner::Point2D* add_robot_vertices();
  ::google::protobuf::RepeatedPtrField< ::or_local_planner::Point2D >*
      mutable_robot_vertices();
  const ::google::protobuf::RepeatedPtrField< ::or_local_planner::Point2D >&
      robot_vertices() const;

  // optional double radius = 2;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  double radius() const;
  void set_radius(double value);

  // optional double front_offset = 3;
  bool has_front_offset() const;
  void clear_front_offset();
  static const int kFrontOffsetFieldNumber = 3;
  double front_offset() const;
  void set_front_offset(double value);

  // optional double front_radius = 4;
  bool has_front_radius() const;
  void clear_front_radius();
  static const int kFrontRadiusFieldNumber = 4;
  double front_radius() const;
  void set_front_radius(double value);

  // optional double rear_offset = 5;
  bool has_rear_offset() const;
  void clear_rear_offset();
  static const int kRearOffsetFieldNumber = 5;
  double rear_offset() const;
  void set_rear_offset(double value);

  // optional double rear_radius = 6;
  bool has_rear_radius() const;
  void clear_rear_radius();
  static const int kRearRadiusFieldNumber = 6;
  double rear_radius() const;
  void set_rear_radius(double value);

  // optional .or_local_planner.FootprintModel.FootprintType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::or_local_planner::FootprintModel_FootprintType type() const;
  void set_type(::or_local_planner::FootprintModel_FootprintType value);

  // @@protoc_insertion_point(class_scope:or_local_planner.FootprintModel)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_radius();
  void clear_has_radius();
  void set_has_front_offset();
  void clear_has_front_offset();
  void set_has_front_radius();
  void clear_has_front_radius();
  void set_has_rear_offset();
  void clear_has_rear_offset();
  void set_has_rear_radius();
  void clear_has_rear_radius();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::or_local_planner::Point2D > robot_vertices_;
  double radius_;
  double front_offset_;
  double front_radius_;
  double rear_offset_;
  double rear_radius_;
  int type_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.Robot) */ {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(Robot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Robot* other);
  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Robot* New() const PROTOBUF_FINAL { return New(NULL); }

  Robot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Robot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_vel_x = 1;
  bool has_max_vel_x() const;
  void clear_max_vel_x();
  static const int kMaxVelXFieldNumber = 1;
  float max_vel_x() const;
  void set_max_vel_x(float value);

  // optional float max_vel_x_backwards = 2;
  bool has_max_vel_x_backwards() const;
  void clear_max_vel_x_backwards();
  static const int kMaxVelXBackwardsFieldNumber = 2;
  float max_vel_x_backwards() const;
  void set_max_vel_x_backwards(float value);

  // optional float max_vel_y = 3;
  bool has_max_vel_y() const;
  void clear_max_vel_y();
  static const int kMaxVelYFieldNumber = 3;
  float max_vel_y() const;
  void set_max_vel_y(float value);

  // optional float max_vel_theta = 4;
  bool has_max_vel_theta() const;
  void clear_max_vel_theta();
  static const int kMaxVelThetaFieldNumber = 4;
  float max_vel_theta() const;
  void set_max_vel_theta(float value);

  // optional float acc_lim_x = 5;
  bool has_acc_lim_x() const;
  void clear_acc_lim_x();
  static const int kAccLimXFieldNumber = 5;
  float acc_lim_x() const;
  void set_acc_lim_x(float value);

  // optional float acc_lim_y = 6;
  bool has_acc_lim_y() const;
  void clear_acc_lim_y();
  static const int kAccLimYFieldNumber = 6;
  float acc_lim_y() const;
  void set_acc_lim_y(float value);

  // optional float acc_lim_theta = 7;
  bool has_acc_lim_theta() const;
  void clear_acc_lim_theta();
  static const int kAccLimThetaFieldNumber = 7;
  float acc_lim_theta() const;
  void set_acc_lim_theta(float value);

  // optional float min_turning_radius = 8;
  bool has_min_turning_radius() const;
  void clear_min_turning_radius();
  static const int kMinTurningRadiusFieldNumber = 8;
  float min_turning_radius() const;
  void set_min_turning_radius(float value);

  // optional float wheelbase = 9;
  bool has_wheelbase() const;
  void clear_wheelbase();
  static const int kWheelbaseFieldNumber = 9;
  float wheelbase() const;
  void set_wheelbase(float value);

  // optional bool cmd_angle_instead_rotvel = 10;
  bool has_cmd_angle_instead_rotvel() const;
  void clear_cmd_angle_instead_rotvel();
  static const int kCmdAngleInsteadRotvelFieldNumber = 10;
  bool cmd_angle_instead_rotvel() const;
  void set_cmd_angle_instead_rotvel(bool value);

  // @@protoc_insertion_point(class_scope:or_local_planner.Robot)
 private:
  void set_has_max_vel_x();
  void clear_has_max_vel_x();
  void set_has_max_vel_x_backwards();
  void clear_has_max_vel_x_backwards();
  void set_has_max_vel_y();
  void clear_has_max_vel_y();
  void set_has_max_vel_theta();
  void clear_has_max_vel_theta();
  void set_has_acc_lim_x();
  void clear_has_acc_lim_x();
  void set_has_acc_lim_y();
  void clear_has_acc_lim_y();
  void set_has_acc_lim_theta();
  void clear_has_acc_lim_theta();
  void set_has_min_turning_radius();
  void clear_has_min_turning_radius();
  void set_has_wheelbase();
  void clear_has_wheelbase();
  void set_has_cmd_angle_instead_rotvel();
  void clear_has_cmd_angle_instead_rotvel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float max_vel_x_;
  float max_vel_x_backwards_;
  float max_vel_y_;
  float max_vel_theta_;
  float acc_lim_x_;
  float acc_lim_y_;
  float acc_lim_theta_;
  float min_turning_radius_;
  float wheelbase_;
  bool cmd_angle_instead_rotvel_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GoalTolerance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.GoalTolerance) */ {
 public:
  GoalTolerance();
  virtual ~GoalTolerance();

  GoalTolerance(const GoalTolerance& from);

  inline GoalTolerance& operator=(const GoalTolerance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GoalTolerance(GoalTolerance&& from) noexcept
    : GoalTolerance() {
    *this = ::std::move(from);
  }

  inline GoalTolerance& operator=(GoalTolerance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalTolerance& default_instance();

  static inline const GoalTolerance* internal_default_instance() {
    return reinterpret_cast<const GoalTolerance*>(
               &_GoalTolerance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GoalTolerance* other);
  friend void swap(GoalTolerance& a, GoalTolerance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GoalTolerance* New() const PROTOBUF_FINAL { return New(NULL); }

  GoalTolerance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GoalTolerance& from);
  void MergeFrom(const GoalTolerance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GoalTolerance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float xy_goal_tolerance = 1;
  bool has_xy_goal_tolerance() const;
  void clear_xy_goal_tolerance();
  static const int kXyGoalToleranceFieldNumber = 1;
  float xy_goal_tolerance() const;
  void set_xy_goal_tolerance(float value);

  // optional float yaw_goal_tolerance = 2;
  bool has_yaw_goal_tolerance() const;
  void clear_yaw_goal_tolerance();
  static const int kYawGoalToleranceFieldNumber = 2;
  float yaw_goal_tolerance() const;
  void set_yaw_goal_tolerance(float value);

  // optional bool free_goal_vel = 3;
  bool has_free_goal_vel() const;
  void clear_free_goal_vel();
  static const int kFreeGoalVelFieldNumber = 3;
  bool free_goal_vel() const;
  void set_free_goal_vel(bool value);

  // @@protoc_insertion_point(class_scope:or_local_planner.GoalTolerance)
 private:
  void set_has_xy_goal_tolerance();
  void clear_has_xy_goal_tolerance();
  void set_has_yaw_goal_tolerance();
  void clear_has_yaw_goal_tolerance();
  void set_has_free_goal_vel();
  void clear_has_free_goal_vel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float xy_goal_tolerance_;
  float yaw_goal_tolerance_;
  bool free_goal_vel_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Obstacles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.Obstacles) */ {
 public:
  Obstacles();
  virtual ~Obstacles();

  Obstacles(const Obstacles& from);

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Obstacles(Obstacles&& from) noexcept
    : Obstacles() {
    *this = ::std::move(from);
  }

  inline Obstacles& operator=(Obstacles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacles& default_instance();

  static inline const Obstacles* internal_default_instance() {
    return reinterpret_cast<const Obstacles*>(
               &_Obstacles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Obstacles* other);
  friend void swap(Obstacles& a, Obstacles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Obstacles* New() const PROTOBUF_FINAL { return New(NULL); }

  Obstacles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Obstacles& from);
  void MergeFrom(const Obstacles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Obstacles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_obstacle_dist = 1;
  bool has_min_obstacle_dist() const;
  void clear_min_obstacle_dist();
  static const int kMinObstacleDistFieldNumber = 1;
  float min_obstacle_dist() const;
  void set_min_obstacle_dist(float value);

  // optional float costmap_obstacles_behind_robot_dist = 2;
  bool has_costmap_obstacles_behind_robot_dist() const;
  void clear_costmap_obstacles_behind_robot_dist();
  static const int kCostmapObstaclesBehindRobotDistFieldNumber = 2;
  float costmap_obstacles_behind_robot_dist() const;
  void set_costmap_obstacles_behind_robot_dist(float value);

  // optional float obstacle_association_cutoff_factor = 3;
  bool has_obstacle_association_cutoff_factor() const;
  void clear_obstacle_association_cutoff_factor();
  static const int kObstacleAssociationCutoffFactorFieldNumber = 3;
  float obstacle_association_cutoff_factor() const;
  void set_obstacle_association_cutoff_factor(float value);

  // optional float obstacle_association_force_inclusion_factor = 4;
  bool has_obstacle_association_force_inclusion_factor() const;
  void clear_obstacle_association_force_inclusion_factor();
  static const int kObstacleAssociationForceInclusionFactorFieldNumber = 4;
  float obstacle_association_force_inclusion_factor() const;
  void set_obstacle_association_force_inclusion_factor(float value);

  // @@protoc_insertion_point(class_scope:or_local_planner.Obstacles)
 private:
  void set_has_min_obstacle_dist();
  void clear_has_min_obstacle_dist();
  void set_has_costmap_obstacles_behind_robot_dist();
  void clear_has_costmap_obstacles_behind_robot_dist();
  void set_has_obstacle_association_cutoff_factor();
  void clear_has_obstacle_association_cutoff_factor();
  void set_has_obstacle_association_force_inclusion_factor();
  void clear_has_obstacle_association_force_inclusion_factor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_obstacle_dist_;
  float costmap_obstacles_behind_robot_dist_;
  float obstacle_association_cutoff_factor_;
  float obstacle_association_force_inclusion_factor_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Optimization : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.Optimization) */ {
 public:
  Optimization();
  virtual ~Optimization();

  Optimization(const Optimization& from);

  inline Optimization& operator=(const Optimization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optimization(Optimization&& from) noexcept
    : Optimization() {
    *this = ::std::move(from);
  }

  inline Optimization& operator=(Optimization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Optimization& default_instance();

  static inline const Optimization* internal_default_instance() {
    return reinterpret_cast<const Optimization*>(
               &_Optimization_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Optimization* other);
  friend void swap(Optimization& a, Optimization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optimization* New() const PROTOBUF_FINAL { return New(NULL); }

  Optimization* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Optimization& from);
  void MergeFrom(const Optimization& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Optimization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 no_inner_iterations = 1;
  bool has_no_inner_iterations() const;
  void clear_no_inner_iterations();
  static const int kNoInnerIterationsFieldNumber = 1;
  ::google::protobuf::int32 no_inner_iterations() const;
  void set_no_inner_iterations(::google::protobuf::int32 value);

  // optional int32 no_outer_iterations = 2;
  bool has_no_outer_iterations() const;
  void clear_no_outer_iterations();
  static const int kNoOuterIterationsFieldNumber = 2;
  ::google::protobuf::int32 no_outer_iterations() const;
  void set_no_outer_iterations(::google::protobuf::int32 value);

  // optional bool optimization_activate = 3;
  bool has_optimization_activate() const;
  void clear_optimization_activate();
  static const int kOptimizationActivateFieldNumber = 3;
  bool optimization_activate() const;
  void set_optimization_activate(bool value);

  // optional bool optimization_verbose = 4;
  bool has_optimization_verbose() const;
  void clear_optimization_verbose();
  static const int kOptimizationVerboseFieldNumber = 4;
  bool optimization_verbose() const;
  void set_optimization_verbose(bool value);

  // optional float penalty_epsilon = 5;
  bool has_penalty_epsilon() const;
  void clear_penalty_epsilon();
  static const int kPenaltyEpsilonFieldNumber = 5;
  float penalty_epsilon() const;
  void set_penalty_epsilon(float value);

  // optional float weight_max_vel_x = 6;
  bool has_weight_max_vel_x() const;
  void clear_weight_max_vel_x();
  static const int kWeightMaxVelXFieldNumber = 6;
  float weight_max_vel_x() const;
  void set_weight_max_vel_x(float value);

  // optional float weight_max_vel_y = 7;
  bool has_weight_max_vel_y() const;
  void clear_weight_max_vel_y();
  static const int kWeightMaxVelYFieldNumber = 7;
  float weight_max_vel_y() const;
  void set_weight_max_vel_y(float value);

  // optional float weight_max_vel_theta = 8;
  bool has_weight_max_vel_theta() const;
  void clear_weight_max_vel_theta();
  static const int kWeightMaxVelThetaFieldNumber = 8;
  float weight_max_vel_theta() const;
  void set_weight_max_vel_theta(float value);

  // optional float weight_acc_lim_x = 9;
  bool has_weight_acc_lim_x() const;
  void clear_weight_acc_lim_x();
  static const int kWeightAccLimXFieldNumber = 9;
  float weight_acc_lim_x() const;
  void set_weight_acc_lim_x(float value);

  // optional float weight_acc_lim_y = 10;
  bool has_weight_acc_lim_y() const;
  void clear_weight_acc_lim_y();
  static const int kWeightAccLimYFieldNumber = 10;
  float weight_acc_lim_y() const;
  void set_weight_acc_lim_y(float value);

  // optional float weight_acc_lim_thet = 11;
  bool has_weight_acc_lim_thet() const;
  void clear_weight_acc_lim_thet();
  static const int kWeightAccLimThetFieldNumber = 11;
  float weight_acc_lim_thet() const;
  void set_weight_acc_lim_thet(float value);

  // optional float weight_kinematics_nh = 12;
  bool has_weight_kinematics_nh() const;
  void clear_weight_kinematics_nh();
  static const int kWeightKinematicsNhFieldNumber = 12;
  float weight_kinematics_nh() const;
  void set_weight_kinematics_nh(float value);

  // optional float weight_kinematics_forward_drive = 13;
  bool has_weight_kinematics_forward_drive() const;
  void clear_weight_kinematics_forward_drive();
  static const int kWeightKinematicsForwardDriveFieldNumber = 13;
  float weight_kinematics_forward_drive() const;
  void set_weight_kinematics_forward_drive(float value);

  // optional float weight_kinematics_turning_radius = 14;
  bool has_weight_kinematics_turning_radius() const;
  void clear_weight_kinematics_turning_radius();
  static const int kWeightKinematicsTurningRadiusFieldNumber = 14;
  float weight_kinematics_turning_radius() const;
  void set_weight_kinematics_turning_radius(float value);

  // optional float weight_optimaltime = 15;
  bool has_weight_optimaltime() const;
  void clear_weight_optimaltime();
  static const int kWeightOptimaltimeFieldNumber = 15;
  float weight_optimaltime() const;
  void set_weight_optimaltime(float value);

  // optional float weight_obstacle = 16;
  bool has_weight_obstacle() const;
  void clear_weight_obstacle();
  static const int kWeightObstacleFieldNumber = 16;
  float weight_obstacle() const;
  void set_weight_obstacle(float value);

  // optional float weight_inflation = 17;
  bool has_weight_inflation() const;
  void clear_weight_inflation();
  static const int kWeightInflationFieldNumber = 17;
  float weight_inflation() const;
  void set_weight_inflation(float value);

  // optional float weight_dynamic_obstacle = 18;
  bool has_weight_dynamic_obstacle() const;
  void clear_weight_dynamic_obstacle();
  static const int kWeightDynamicObstacleFieldNumber = 18;
  float weight_dynamic_obstacle() const;
  void set_weight_dynamic_obstacle(float value);

  // optional float weight_viapoint = 19;
  bool has_weight_viapoint() const;
  void clear_weight_viapoint();
  static const int kWeightViapointFieldNumber = 19;
  float weight_viapoint() const;
  void set_weight_viapoint(float value);

  // optional float weight_adapt_factor = 20;
  bool has_weight_adapt_factor() const;
  void clear_weight_adapt_factor();
  static const int kWeightAdaptFactorFieldNumber = 20;
  float weight_adapt_factor() const;
  void set_weight_adapt_factor(float value);

  // optional float weight_prefer_rotdir = 21;
  bool has_weight_prefer_rotdir() const;
  void clear_weight_prefer_rotdir();
  static const int kWeightPreferRotdirFieldNumber = 21;
  float weight_prefer_rotdir() const;
  void set_weight_prefer_rotdir(float value);

  // optional float weight_acc_lim_theta = 22;
  bool has_weight_acc_lim_theta() const;
  void clear_weight_acc_lim_theta();
  static const int kWeightAccLimThetaFieldNumber = 22;
  float weight_acc_lim_theta() const;
  void set_weight_acc_lim_theta(float value);

  // @@protoc_insertion_point(class_scope:or_local_planner.Optimization)
 private:
  void set_has_no_inner_iterations();
  void clear_has_no_inner_iterations();
  void set_has_no_outer_iterations();
  void clear_has_no_outer_iterations();
  void set_has_optimization_activate();
  void clear_has_optimization_activate();
  void set_has_optimization_verbose();
  void clear_has_optimization_verbose();
  void set_has_penalty_epsilon();
  void clear_has_penalty_epsilon();
  void set_has_weight_max_vel_x();
  void clear_has_weight_max_vel_x();
  void set_has_weight_max_vel_y();
  void clear_has_weight_max_vel_y();
  void set_has_weight_max_vel_theta();
  void clear_has_weight_max_vel_theta();
  void set_has_weight_acc_lim_x();
  void clear_has_weight_acc_lim_x();
  void set_has_weight_acc_lim_y();
  void clear_has_weight_acc_lim_y();
  void set_has_weight_acc_lim_thet();
  void clear_has_weight_acc_lim_thet();
  void set_has_weight_kinematics_nh();
  void clear_has_weight_kinematics_nh();
  void set_has_weight_kinematics_forward_drive();
  void clear_has_weight_kinematics_forward_drive();
  void set_has_weight_kinematics_turning_radius();
  void clear_has_weight_kinematics_turning_radius();
  void set_has_weight_optimaltime();
  void clear_has_weight_optimaltime();
  void set_has_weight_obstacle();
  void clear_has_weight_obstacle();
  void set_has_weight_inflation();
  void clear_has_weight_inflation();
  void set_has_weight_dynamic_obstacle();
  void clear_has_weight_dynamic_obstacle();
  void set_has_weight_viapoint();
  void clear_has_weight_viapoint();
  void set_has_weight_adapt_factor();
  void clear_has_weight_adapt_factor();
  void set_has_weight_prefer_rotdir();
  void clear_has_weight_prefer_rotdir();
  void set_has_weight_acc_lim_theta();
  void clear_has_weight_acc_lim_theta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 no_inner_iterations_;
  ::google::protobuf::int32 no_outer_iterations_;
  bool optimization_activate_;
  bool optimization_verbose_;
  float penalty_epsilon_;
  float weight_max_vel_x_;
  float weight_max_vel_y_;
  float weight_max_vel_theta_;
  float weight_acc_lim_x_;
  float weight_acc_lim_y_;
  float weight_acc_lim_thet_;
  float weight_kinematics_nh_;
  float weight_kinematics_forward_drive_;
  float weight_kinematics_turning_radius_;
  float weight_optimaltime_;
  float weight_obstacle_;
  float weight_inflation_;
  float weight_dynamic_obstacle_;
  float weight_viapoint_;
  float weight_adapt_factor_;
  float weight_prefer_rotdir_;
  float weight_acc_lim_theta_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:or_local_planner.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const PROTOBUF_FINAL { return New(NULL); }

  Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .or_local_planner.FootprintModel robot_type = 7;
  int robot_type_size() const;
  void clear_robot_type();
  static const int kRobotTypeFieldNumber = 7;
  const ::or_local_planner::FootprintModel& robot_type(int index) const;
  ::or_local_planner::FootprintModel* mutable_robot_type(int index);
  ::or_local_planner::FootprintModel* add_robot_type();
  ::google::protobuf::RepeatedPtrField< ::or_local_planner::FootprintModel >*
      mutable_robot_type();
  const ::google::protobuf::RepeatedPtrField< ::or_local_planner::FootprintModel >&
      robot_type() const;

  // optional .or_local_planner.FrameID opt_frame = 1;
  bool has_opt_frame() const;
  void clear_opt_frame();
  static const int kOptFrameFieldNumber = 1;
  const ::or_local_planner::FrameID& opt_frame() const;
  ::or_local_planner::FrameID* mutable_opt_frame();
  ::or_local_planner::FrameID* release_opt_frame();
  void set_allocated_opt_frame(::or_local_planner::FrameID* opt_frame);

  // optional .or_local_planner.Trajectory trajectory_opt = 2;
  bool has_trajectory_opt() const;
  void clear_trajectory_opt();
  static const int kTrajectoryOptFieldNumber = 2;
  const ::or_local_planner::Trajectory& trajectory_opt() const;
  ::or_local_planner::Trajectory* mutable_trajectory_opt();
  ::or_local_planner::Trajectory* release_trajectory_opt();
  void set_allocated_trajectory_opt(::or_local_planner::Trajectory* trajectory_opt);

  // optional .or_local_planner.Robot kinematics_opt = 3;
  bool has_kinematics_opt() const;
  void clear_kinematics_opt();
  static const int kKinematicsOptFieldNumber = 3;
  const ::or_local_planner::Robot& kinematics_opt() const;
  ::or_local_planner::Robot* mutable_kinematics_opt();
  ::or_local_planner::Robot* release_kinematics_opt();
  void set_allocated_kinematics_opt(::or_local_planner::Robot* kinematics_opt);

  // optional .or_local_planner.GoalTolerance tolerance_opt = 4;
  bool has_tolerance_opt() const;
  void clear_tolerance_opt();
  static const int kToleranceOptFieldNumber = 4;
  const ::or_local_planner::GoalTolerance& tolerance_opt() const;
  ::or_local_planner::GoalTolerance* mutable_tolerance_opt();
  ::or_local_planner::GoalTolerance* release_tolerance_opt();
  void set_allocated_tolerance_opt(::or_local_planner::GoalTolerance* tolerance_opt);

  // optional .or_local_planner.Obstacles obstacles_opt = 5;
  bool has_obstacles_opt() const;
  void clear_obstacles_opt();
  static const int kObstaclesOptFieldNumber = 5;
  const ::or_local_planner::Obstacles& obstacles_opt() const;
  ::or_local_planner::Obstacles* mutable_obstacles_opt();
  ::or_local_planner::Obstacles* release_obstacles_opt();
  void set_allocated_obstacles_opt(::or_local_planner::Obstacles* obstacles_opt);

  // optional .or_local_planner.Optimization optimize_info = 6;
  bool has_optimize_info() const;
  void clear_optimize_info();
  static const int kOptimizeInfoFieldNumber = 6;
  const ::or_local_planner::Optimization& optimize_info() const;
  ::or_local_planner::Optimization* mutable_optimize_info();
  ::or_local_planner::Optimization* release_optimize_info();
  void set_allocated_optimize_info(::or_local_planner::Optimization* optimize_info);

  // @@protoc_insertion_point(class_scope:or_local_planner.Config)
 private:
  void set_has_opt_frame();
  void clear_has_opt_frame();
  void set_has_trajectory_opt();
  void clear_has_trajectory_opt();
  void set_has_kinematics_opt();
  void clear_has_kinematics_opt();
  void set_has_tolerance_opt();
  void clear_has_tolerance_opt();
  void set_has_obstacles_opt();
  void clear_has_obstacles_opt();
  void set_has_optimize_info();
  void clear_has_optimize_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::or_local_planner::FootprintModel > robot_type_;
  ::or_local_planner::FrameID* opt_frame_;
  ::or_local_planner::Trajectory* trajectory_opt_;
  ::or_local_planner::Robot* kinematics_opt_;
  ::or_local_planner::GoalTolerance* tolerance_opt_;
  ::or_local_planner::Obstacles* obstacles_opt_;
  ::or_local_planner::Optimization* optimize_info_;
  friend struct protobuf_timed_5felastic_5fband_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FrameID

// optional string odom_frame = 1;
inline bool FrameID::has_odom_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameID::set_has_odom_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameID::clear_has_odom_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameID::clear_odom_frame() {
  odom_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_odom_frame();
}
inline const ::std::string& FrameID::odom_frame() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FrameID.odom_frame)
  return odom_frame_.GetNoArena();
}
inline void FrameID::set_odom_frame(const ::std::string& value) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:or_local_planner.FrameID.odom_frame)
}
#if LANG_CXX11
inline void FrameID::set_odom_frame(::std::string&& value) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:or_local_planner.FrameID.odom_frame)
}
#endif
inline void FrameID::set_odom_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:or_local_planner.FrameID.odom_frame)
}
inline void FrameID::set_odom_frame(const char* value, size_t size) {
  set_has_odom_frame();
  odom_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:or_local_planner.FrameID.odom_frame)
}
inline ::std::string* FrameID::mutable_odom_frame() {
  set_has_odom_frame();
  // @@protoc_insertion_point(field_mutable:or_local_planner.FrameID.odom_frame)
  return odom_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FrameID::release_odom_frame() {
  // @@protoc_insertion_point(field_release:or_local_planner.FrameID.odom_frame)
  clear_has_odom_frame();
  return odom_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FrameID::set_allocated_odom_frame(::std::string* odom_frame) {
  if (odom_frame != NULL) {
    set_has_odom_frame();
  } else {
    clear_has_odom_frame();
  }
  odom_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), odom_frame);
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.FrameID.odom_frame)
}

// optional string map_frame = 2;
inline bool FrameID::has_map_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameID::set_has_map_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameID::clear_has_map_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameID::clear_map_frame() {
  map_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_frame();
}
inline const ::std::string& FrameID::map_frame() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FrameID.map_frame)
  return map_frame_.GetNoArena();
}
inline void FrameID::set_map_frame(const ::std::string& value) {
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:or_local_planner.FrameID.map_frame)
}
#if LANG_CXX11
inline void FrameID::set_map_frame(::std::string&& value) {
  set_has_map_frame();
  map_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:or_local_planner.FrameID.map_frame)
}
#endif
inline void FrameID::set_map_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:or_local_planner.FrameID.map_frame)
}
inline void FrameID::set_map_frame(const char* value, size_t size) {
  set_has_map_frame();
  map_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:or_local_planner.FrameID.map_frame)
}
inline ::std::string* FrameID::mutable_map_frame() {
  set_has_map_frame();
  // @@protoc_insertion_point(field_mutable:or_local_planner.FrameID.map_frame)
  return map_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FrameID::release_map_frame() {
  // @@protoc_insertion_point(field_release:or_local_planner.FrameID.map_frame)
  clear_has_map_frame();
  return map_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FrameID::set_allocated_map_frame(::std::string* map_frame) {
  if (map_frame != NULL) {
    set_has_map_frame();
  } else {
    clear_has_map_frame();
  }
  map_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_frame);
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.FrameID.map_frame)
}

// -------------------------------------------------------------------

// Point2D

// optional float x = 1;
inline bool Point2D::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2D::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2D::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2D::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point2D::x() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Point2D.x)
  return x_;
}
inline void Point2D::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Point2D.x)
}

// optional float y = 2;
inline bool Point2D::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2D::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2D::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2D::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point2D::y() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Point2D.y)
  return y_;
}
inline void Point2D::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Point2D.y)
}

// -------------------------------------------------------------------

// Trajectory

// optional bool teb_autosize = 1;
inline bool Trajectory::has_teb_autosize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trajectory::set_has_teb_autosize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trajectory::clear_has_teb_autosize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trajectory::clear_teb_autosize() {
  teb_autosize_ = false;
  clear_has_teb_autosize();
}
inline bool Trajectory::teb_autosize() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.teb_autosize)
  return teb_autosize_;
}
inline void Trajectory::set_teb_autosize(bool value) {
  set_has_teb_autosize();
  teb_autosize_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.teb_autosize)
}

// optional float dt_ref = 2;
inline bool Trajectory::has_dt_ref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trajectory::set_has_dt_ref() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trajectory::clear_has_dt_ref() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trajectory::clear_dt_ref() {
  dt_ref_ = 0;
  clear_has_dt_ref();
}
inline float Trajectory::dt_ref() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.dt_ref)
  return dt_ref_;
}
inline void Trajectory::set_dt_ref(float value) {
  set_has_dt_ref();
  dt_ref_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.dt_ref)
}

// optional float dt_hysteresis = 3;
inline bool Trajectory::has_dt_hysteresis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trajectory::set_has_dt_hysteresis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trajectory::clear_has_dt_hysteresis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trajectory::clear_dt_hysteresis() {
  dt_hysteresis_ = 0;
  clear_has_dt_hysteresis();
}
inline float Trajectory::dt_hysteresis() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.dt_hysteresis)
  return dt_hysteresis_;
}
inline void Trajectory::set_dt_hysteresis(float value) {
  set_has_dt_hysteresis();
  dt_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.dt_hysteresis)
}

// optional bool global_plan_overwrite_orientation = 4;
inline bool Trajectory::has_global_plan_overwrite_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Trajectory::set_has_global_plan_overwrite_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Trajectory::clear_has_global_plan_overwrite_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Trajectory::clear_global_plan_overwrite_orientation() {
  global_plan_overwrite_orientation_ = false;
  clear_has_global_plan_overwrite_orientation();
}
inline bool Trajectory::global_plan_overwrite_orientation() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.global_plan_overwrite_orientation)
  return global_plan_overwrite_orientation_;
}
inline void Trajectory::set_global_plan_overwrite_orientation(bool value) {
  set_has_global_plan_overwrite_orientation();
  global_plan_overwrite_orientation_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.global_plan_overwrite_orientation)
}

// optional bool allow_init_with_backwards_motion = 5;
inline bool Trajectory::has_allow_init_with_backwards_motion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Trajectory::set_has_allow_init_with_backwards_motion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Trajectory::clear_has_allow_init_with_backwards_motion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Trajectory::clear_allow_init_with_backwards_motion() {
  allow_init_with_backwards_motion_ = false;
  clear_has_allow_init_with_backwards_motion();
}
inline bool Trajectory::allow_init_with_backwards_motion() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.allow_init_with_backwards_motion)
  return allow_init_with_backwards_motion_;
}
inline void Trajectory::set_allow_init_with_backwards_motion(bool value) {
  set_has_allow_init_with_backwards_motion();
  allow_init_with_backwards_motion_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.allow_init_with_backwards_motion)
}

// optional float global_plan_viapoint_sep = 6;
inline bool Trajectory::has_global_plan_viapoint_sep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Trajectory::set_has_global_plan_viapoint_sep() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Trajectory::clear_has_global_plan_viapoint_sep() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Trajectory::clear_global_plan_viapoint_sep() {
  global_plan_viapoint_sep_ = 0;
  clear_has_global_plan_viapoint_sep();
}
inline float Trajectory::global_plan_viapoint_sep() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.global_plan_viapoint_sep)
  return global_plan_viapoint_sep_;
}
inline void Trajectory::set_global_plan_viapoint_sep(float value) {
  set_has_global_plan_viapoint_sep();
  global_plan_viapoint_sep_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.global_plan_viapoint_sep)
}

// optional bool via_points_ordered = 7;
inline bool Trajectory::has_via_points_ordered() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Trajectory::set_has_via_points_ordered() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Trajectory::clear_has_via_points_ordered() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Trajectory::clear_via_points_ordered() {
  via_points_ordered_ = false;
  clear_has_via_points_ordered();
}
inline bool Trajectory::via_points_ordered() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.via_points_ordered)
  return via_points_ordered_;
}
inline void Trajectory::set_via_points_ordered(bool value) {
  set_has_via_points_ordered();
  via_points_ordered_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.via_points_ordered)
}

// optional float max_global_plan_lookahead_dist = 8;
inline bool Trajectory::has_max_global_plan_lookahead_dist() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Trajectory::set_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Trajectory::clear_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Trajectory::clear_max_global_plan_lookahead_dist() {
  max_global_plan_lookahead_dist_ = 0;
  clear_has_max_global_plan_lookahead_dist();
}
inline float Trajectory::max_global_plan_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.max_global_plan_lookahead_dist)
  return max_global_plan_lookahead_dist_;
}
inline void Trajectory::set_max_global_plan_lookahead_dist(float value) {
  set_has_max_global_plan_lookahead_dist();
  max_global_plan_lookahead_dist_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.max_global_plan_lookahead_dist)
}

// optional bool exact_arc_length = 9;
inline bool Trajectory::has_exact_arc_length() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Trajectory::set_has_exact_arc_length() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Trajectory::clear_has_exact_arc_length() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Trajectory::clear_exact_arc_length() {
  exact_arc_length_ = false;
  clear_has_exact_arc_length();
}
inline bool Trajectory::exact_arc_length() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.exact_arc_length)
  return exact_arc_length_;
}
inline void Trajectory::set_exact_arc_length(bool value) {
  set_has_exact_arc_length();
  exact_arc_length_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.exact_arc_length)
}

// optional float force_reinit_new_goal_dist = 10;
inline bool Trajectory::has_force_reinit_new_goal_dist() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Trajectory::set_has_force_reinit_new_goal_dist() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Trajectory::clear_has_force_reinit_new_goal_dist() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Trajectory::clear_force_reinit_new_goal_dist() {
  force_reinit_new_goal_dist_ = 0;
  clear_has_force_reinit_new_goal_dist();
}
inline float Trajectory::force_reinit_new_goal_dist() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.force_reinit_new_goal_dist)
  return force_reinit_new_goal_dist_;
}
inline void Trajectory::set_force_reinit_new_goal_dist(float value) {
  set_has_force_reinit_new_goal_dist();
  force_reinit_new_goal_dist_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.force_reinit_new_goal_dist)
}

// optional int64 feasibility_check_no_poses = 11;
inline bool Trajectory::has_feasibility_check_no_poses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Trajectory::set_has_feasibility_check_no_poses() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Trajectory::clear_has_feasibility_check_no_poses() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Trajectory::clear_feasibility_check_no_poses() {
  feasibility_check_no_poses_ = GOOGLE_LONGLONG(0);
  clear_has_feasibility_check_no_poses();
}
inline ::google::protobuf::int64 Trajectory::feasibility_check_no_poses() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.feasibility_check_no_poses)
  return feasibility_check_no_poses_;
}
inline void Trajectory::set_feasibility_check_no_poses(::google::protobuf::int64 value) {
  set_has_feasibility_check_no_poses();
  feasibility_check_no_poses_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.feasibility_check_no_poses)
}

// optional bool publish_feedback = 12;
inline bool Trajectory::has_publish_feedback() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Trajectory::set_has_publish_feedback() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Trajectory::clear_has_publish_feedback() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Trajectory::clear_publish_feedback() {
  publish_feedback_ = false;
  clear_has_publish_feedback();
}
inline bool Trajectory::publish_feedback() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.publish_feedback)
  return publish_feedback_;
}
inline void Trajectory::set_publish_feedback(bool value) {
  set_has_publish_feedback();
  publish_feedback_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.publish_feedback)
}

// optional int64 min_samples = 13;
inline bool Trajectory::has_min_samples() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Trajectory::set_has_min_samples() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Trajectory::clear_has_min_samples() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Trajectory::clear_min_samples() {
  min_samples_ = GOOGLE_LONGLONG(0);
  clear_has_min_samples();
}
inline ::google::protobuf::int64 Trajectory::min_samples() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.min_samples)
  return min_samples_;
}
inline void Trajectory::set_min_samples(::google::protobuf::int64 value) {
  set_has_min_samples();
  min_samples_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.min_samples)
}

// optional int64 max_samples = 14;
inline bool Trajectory::has_max_samples() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Trajectory::set_has_max_samples() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Trajectory::clear_has_max_samples() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Trajectory::clear_max_samples() {
  max_samples_ = GOOGLE_LONGLONG(0);
  clear_has_max_samples();
}
inline ::google::protobuf::int64 Trajectory::max_samples() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Trajectory.max_samples)
  return max_samples_;
}
inline void Trajectory::set_max_samples(::google::protobuf::int64 value) {
  set_has_max_samples();
  max_samples_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Trajectory.max_samples)
}

// -------------------------------------------------------------------

// FootprintModel

// optional .or_local_planner.FootprintModel.FootprintType type = 1;
inline bool FootprintModel::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FootprintModel::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FootprintModel::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FootprintModel::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::or_local_planner::FootprintModel_FootprintType FootprintModel::type() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FootprintModel.type)
  return static_cast< ::or_local_planner::FootprintModel_FootprintType >(type_);
}
inline void FootprintModel::set_type(::or_local_planner::FootprintModel_FootprintType value) {
  assert(::or_local_planner::FootprintModel_FootprintType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.FootprintModel.type)
}

// optional double radius = 2;
inline bool FootprintModel::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FootprintModel::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FootprintModel::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FootprintModel::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double FootprintModel::radius() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FootprintModel.radius)
  return radius_;
}
inline void FootprintModel::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.FootprintModel.radius)
}

// optional double front_offset = 3;
inline bool FootprintModel::has_front_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FootprintModel::set_has_front_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FootprintModel::clear_has_front_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FootprintModel::clear_front_offset() {
  front_offset_ = 0;
  clear_has_front_offset();
}
inline double FootprintModel::front_offset() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FootprintModel.front_offset)
  return front_offset_;
}
inline void FootprintModel::set_front_offset(double value) {
  set_has_front_offset();
  front_offset_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.FootprintModel.front_offset)
}

// optional double front_radius = 4;
inline bool FootprintModel::has_front_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FootprintModel::set_has_front_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FootprintModel::clear_has_front_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FootprintModel::clear_front_radius() {
  front_radius_ = 0;
  clear_has_front_radius();
}
inline double FootprintModel::front_radius() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FootprintModel.front_radius)
  return front_radius_;
}
inline void FootprintModel::set_front_radius(double value) {
  set_has_front_radius();
  front_radius_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.FootprintModel.front_radius)
}

// optional double rear_offset = 5;
inline bool FootprintModel::has_rear_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FootprintModel::set_has_rear_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FootprintModel::clear_has_rear_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FootprintModel::clear_rear_offset() {
  rear_offset_ = 0;
  clear_has_rear_offset();
}
inline double FootprintModel::rear_offset() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FootprintModel.rear_offset)
  return rear_offset_;
}
inline void FootprintModel::set_rear_offset(double value) {
  set_has_rear_offset();
  rear_offset_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.FootprintModel.rear_offset)
}

// optional double rear_radius = 6;
inline bool FootprintModel::has_rear_radius() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FootprintModel::set_has_rear_radius() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FootprintModel::clear_has_rear_radius() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FootprintModel::clear_rear_radius() {
  rear_radius_ = 0;
  clear_has_rear_radius();
}
inline double FootprintModel::rear_radius() const {
  // @@protoc_insertion_point(field_get:or_local_planner.FootprintModel.rear_radius)
  return rear_radius_;
}
inline void FootprintModel::set_rear_radius(double value) {
  set_has_rear_radius();
  rear_radius_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.FootprintModel.rear_radius)
}

// repeated .or_local_planner.Point2D robot_vertices = 7;
inline int FootprintModel::robot_vertices_size() const {
  return robot_vertices_.size();
}
inline void FootprintModel::clear_robot_vertices() {
  robot_vertices_.Clear();
}
inline const ::or_local_planner::Point2D& FootprintModel::robot_vertices(int index) const {
  // @@protoc_insertion_point(field_get:or_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Get(index);
}
inline ::or_local_planner::Point2D* FootprintModel::mutable_robot_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:or_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Mutable(index);
}
inline ::or_local_planner::Point2D* FootprintModel::add_robot_vertices() {
  // @@protoc_insertion_point(field_add:or_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::or_local_planner::Point2D >*
FootprintModel::mutable_robot_vertices() {
  // @@protoc_insertion_point(field_mutable_list:or_local_planner.FootprintModel.robot_vertices)
  return &robot_vertices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::or_local_planner::Point2D >&
FootprintModel::robot_vertices() const {
  // @@protoc_insertion_point(field_list:or_local_planner.FootprintModel.robot_vertices)
  return robot_vertices_;
}

// -------------------------------------------------------------------

// Robot

// optional float max_vel_x = 1;
inline bool Robot::has_max_vel_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_max_vel_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_max_vel_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_max_vel_x() {
  max_vel_x_ = 0;
  clear_has_max_vel_x();
}
inline float Robot::max_vel_x() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.max_vel_x)
  return max_vel_x_;
}
inline void Robot::set_max_vel_x(float value) {
  set_has_max_vel_x();
  max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.max_vel_x)
}

// optional float max_vel_x_backwards = 2;
inline bool Robot::has_max_vel_x_backwards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_max_vel_x_backwards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_max_vel_x_backwards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_max_vel_x_backwards() {
  max_vel_x_backwards_ = 0;
  clear_has_max_vel_x_backwards();
}
inline float Robot::max_vel_x_backwards() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.max_vel_x_backwards)
  return max_vel_x_backwards_;
}
inline void Robot::set_max_vel_x_backwards(float value) {
  set_has_max_vel_x_backwards();
  max_vel_x_backwards_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.max_vel_x_backwards)
}

// optional float max_vel_y = 3;
inline bool Robot::has_max_vel_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Robot::set_has_max_vel_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Robot::clear_has_max_vel_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Robot::clear_max_vel_y() {
  max_vel_y_ = 0;
  clear_has_max_vel_y();
}
inline float Robot::max_vel_y() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.max_vel_y)
  return max_vel_y_;
}
inline void Robot::set_max_vel_y(float value) {
  set_has_max_vel_y();
  max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.max_vel_y)
}

// optional float max_vel_theta = 4;
inline bool Robot::has_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Robot::set_has_max_vel_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Robot::clear_has_max_vel_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Robot::clear_max_vel_theta() {
  max_vel_theta_ = 0;
  clear_has_max_vel_theta();
}
inline float Robot::max_vel_theta() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.max_vel_theta)
  return max_vel_theta_;
}
inline void Robot::set_max_vel_theta(float value) {
  set_has_max_vel_theta();
  max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.max_vel_theta)
}

// optional float acc_lim_x = 5;
inline bool Robot::has_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Robot::set_has_acc_lim_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Robot::clear_has_acc_lim_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Robot::clear_acc_lim_x() {
  acc_lim_x_ = 0;
  clear_has_acc_lim_x();
}
inline float Robot::acc_lim_x() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.acc_lim_x)
  return acc_lim_x_;
}
inline void Robot::set_acc_lim_x(float value) {
  set_has_acc_lim_x();
  acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.acc_lim_x)
}

// optional float acc_lim_y = 6;
inline bool Robot::has_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Robot::set_has_acc_lim_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Robot::clear_has_acc_lim_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Robot::clear_acc_lim_y() {
  acc_lim_y_ = 0;
  clear_has_acc_lim_y();
}
inline float Robot::acc_lim_y() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.acc_lim_y)
  return acc_lim_y_;
}
inline void Robot::set_acc_lim_y(float value) {
  set_has_acc_lim_y();
  acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.acc_lim_y)
}

// optional float acc_lim_theta = 7;
inline bool Robot::has_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Robot::set_has_acc_lim_theta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Robot::clear_has_acc_lim_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Robot::clear_acc_lim_theta() {
  acc_lim_theta_ = 0;
  clear_has_acc_lim_theta();
}
inline float Robot::acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.acc_lim_theta)
  return acc_lim_theta_;
}
inline void Robot::set_acc_lim_theta(float value) {
  set_has_acc_lim_theta();
  acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.acc_lim_theta)
}

// optional float min_turning_radius = 8;
inline bool Robot::has_min_turning_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Robot::set_has_min_turning_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Robot::clear_has_min_turning_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Robot::clear_min_turning_radius() {
  min_turning_radius_ = 0;
  clear_has_min_turning_radius();
}
inline float Robot::min_turning_radius() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.min_turning_radius)
  return min_turning_radius_;
}
inline void Robot::set_min_turning_radius(float value) {
  set_has_min_turning_radius();
  min_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.min_turning_radius)
}

// optional float wheelbase = 9;
inline bool Robot::has_wheelbase() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Robot::set_has_wheelbase() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Robot::clear_has_wheelbase() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Robot::clear_wheelbase() {
  wheelbase_ = 0;
  clear_has_wheelbase();
}
inline float Robot::wheelbase() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.wheelbase)
  return wheelbase_;
}
inline void Robot::set_wheelbase(float value) {
  set_has_wheelbase();
  wheelbase_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.wheelbase)
}

// optional bool cmd_angle_instead_rotvel = 10;
inline bool Robot::has_cmd_angle_instead_rotvel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Robot::set_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Robot::clear_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Robot::clear_cmd_angle_instead_rotvel() {
  cmd_angle_instead_rotvel_ = false;
  clear_has_cmd_angle_instead_rotvel();
}
inline bool Robot::cmd_angle_instead_rotvel() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Robot.cmd_angle_instead_rotvel)
  return cmd_angle_instead_rotvel_;
}
inline void Robot::set_cmd_angle_instead_rotvel(bool value) {
  set_has_cmd_angle_instead_rotvel();
  cmd_angle_instead_rotvel_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Robot.cmd_angle_instead_rotvel)
}

// -------------------------------------------------------------------

// GoalTolerance

// optional float xy_goal_tolerance = 1;
inline bool GoalTolerance::has_xy_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalTolerance::set_has_xy_goal_tolerance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalTolerance::clear_has_xy_goal_tolerance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalTolerance::clear_xy_goal_tolerance() {
  xy_goal_tolerance_ = 0;
  clear_has_xy_goal_tolerance();
}
inline float GoalTolerance::xy_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:or_local_planner.GoalTolerance.xy_goal_tolerance)
  return xy_goal_tolerance_;
}
inline void GoalTolerance::set_xy_goal_tolerance(float value) {
  set_has_xy_goal_tolerance();
  xy_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.GoalTolerance.xy_goal_tolerance)
}

// optional float yaw_goal_tolerance = 2;
inline bool GoalTolerance::has_yaw_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalTolerance::set_has_yaw_goal_tolerance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalTolerance::clear_has_yaw_goal_tolerance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalTolerance::clear_yaw_goal_tolerance() {
  yaw_goal_tolerance_ = 0;
  clear_has_yaw_goal_tolerance();
}
inline float GoalTolerance::yaw_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:or_local_planner.GoalTolerance.yaw_goal_tolerance)
  return yaw_goal_tolerance_;
}
inline void GoalTolerance::set_yaw_goal_tolerance(float value) {
  set_has_yaw_goal_tolerance();
  yaw_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.GoalTolerance.yaw_goal_tolerance)
}

// optional bool free_goal_vel = 3;
inline bool GoalTolerance::has_free_goal_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalTolerance::set_has_free_goal_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalTolerance::clear_has_free_goal_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalTolerance::clear_free_goal_vel() {
  free_goal_vel_ = false;
  clear_has_free_goal_vel();
}
inline bool GoalTolerance::free_goal_vel() const {
  // @@protoc_insertion_point(field_get:or_local_planner.GoalTolerance.free_goal_vel)
  return free_goal_vel_;
}
inline void GoalTolerance::set_free_goal_vel(bool value) {
  set_has_free_goal_vel();
  free_goal_vel_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.GoalTolerance.free_goal_vel)
}

// -------------------------------------------------------------------

// Obstacles

// optional float min_obstacle_dist = 1;
inline bool Obstacles::has_min_obstacle_dist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacles::set_has_min_obstacle_dist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacles::clear_has_min_obstacle_dist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacles::clear_min_obstacle_dist() {
  min_obstacle_dist_ = 0;
  clear_has_min_obstacle_dist();
}
inline float Obstacles::min_obstacle_dist() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Obstacles.min_obstacle_dist)
  return min_obstacle_dist_;
}
inline void Obstacles::set_min_obstacle_dist(float value) {
  set_has_min_obstacle_dist();
  min_obstacle_dist_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Obstacles.min_obstacle_dist)
}

// optional float costmap_obstacles_behind_robot_dist = 2;
inline bool Obstacles::has_costmap_obstacles_behind_robot_dist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacles::set_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacles::clear_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacles::clear_costmap_obstacles_behind_robot_dist() {
  costmap_obstacles_behind_robot_dist_ = 0;
  clear_has_costmap_obstacles_behind_robot_dist();
}
inline float Obstacles::costmap_obstacles_behind_robot_dist() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
  return costmap_obstacles_behind_robot_dist_;
}
inline void Obstacles::set_costmap_obstacles_behind_robot_dist(float value) {
  set_has_costmap_obstacles_behind_robot_dist();
  costmap_obstacles_behind_robot_dist_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Obstacles.costmap_obstacles_behind_robot_dist)
}

// optional float obstacle_association_cutoff_factor = 3;
inline bool Obstacles::has_obstacle_association_cutoff_factor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacles::set_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacles::clear_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacles::clear_obstacle_association_cutoff_factor() {
  obstacle_association_cutoff_factor_ = 0;
  clear_has_obstacle_association_cutoff_factor();
}
inline float Obstacles::obstacle_association_cutoff_factor() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Obstacles.obstacle_association_cutoff_factor)
  return obstacle_association_cutoff_factor_;
}
inline void Obstacles::set_obstacle_association_cutoff_factor(float value) {
  set_has_obstacle_association_cutoff_factor();
  obstacle_association_cutoff_factor_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Obstacles.obstacle_association_cutoff_factor)
}

// optional float obstacle_association_force_inclusion_factor = 4;
inline bool Obstacles::has_obstacle_association_force_inclusion_factor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacles::set_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacles::clear_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacles::clear_obstacle_association_force_inclusion_factor() {
  obstacle_association_force_inclusion_factor_ = 0;
  clear_has_obstacle_association_force_inclusion_factor();
}
inline float Obstacles::obstacle_association_force_inclusion_factor() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
  return obstacle_association_force_inclusion_factor_;
}
inline void Obstacles::set_obstacle_association_force_inclusion_factor(float value) {
  set_has_obstacle_association_force_inclusion_factor();
  obstacle_association_force_inclusion_factor_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Obstacles.obstacle_association_force_inclusion_factor)
}

// -------------------------------------------------------------------

// Optimization

// optional int32 no_inner_iterations = 1;
inline bool Optimization::has_no_inner_iterations() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Optimization::set_has_no_inner_iterations() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Optimization::clear_has_no_inner_iterations() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Optimization::clear_no_inner_iterations() {
  no_inner_iterations_ = 0;
  clear_has_no_inner_iterations();
}
inline ::google::protobuf::int32 Optimization::no_inner_iterations() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.no_inner_iterations)
  return no_inner_iterations_;
}
inline void Optimization::set_no_inner_iterations(::google::protobuf::int32 value) {
  set_has_no_inner_iterations();
  no_inner_iterations_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.no_inner_iterations)
}

// optional int32 no_outer_iterations = 2;
inline bool Optimization::has_no_outer_iterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Optimization::set_has_no_outer_iterations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Optimization::clear_has_no_outer_iterations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Optimization::clear_no_outer_iterations() {
  no_outer_iterations_ = 0;
  clear_has_no_outer_iterations();
}
inline ::google::protobuf::int32 Optimization::no_outer_iterations() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.no_outer_iterations)
  return no_outer_iterations_;
}
inline void Optimization::set_no_outer_iterations(::google::protobuf::int32 value) {
  set_has_no_outer_iterations();
  no_outer_iterations_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.no_outer_iterations)
}

// optional bool optimization_activate = 3;
inline bool Optimization::has_optimization_activate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Optimization::set_has_optimization_activate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Optimization::clear_has_optimization_activate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Optimization::clear_optimization_activate() {
  optimization_activate_ = false;
  clear_has_optimization_activate();
}
inline bool Optimization::optimization_activate() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.optimization_activate)
  return optimization_activate_;
}
inline void Optimization::set_optimization_activate(bool value) {
  set_has_optimization_activate();
  optimization_activate_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.optimization_activate)
}

// optional bool optimization_verbose = 4;
inline bool Optimization::has_optimization_verbose() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Optimization::set_has_optimization_verbose() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Optimization::clear_has_optimization_verbose() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Optimization::clear_optimization_verbose() {
  optimization_verbose_ = false;
  clear_has_optimization_verbose();
}
inline bool Optimization::optimization_verbose() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.optimization_verbose)
  return optimization_verbose_;
}
inline void Optimization::set_optimization_verbose(bool value) {
  set_has_optimization_verbose();
  optimization_verbose_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.optimization_verbose)
}

// optional float penalty_epsilon = 5;
inline bool Optimization::has_penalty_epsilon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Optimization::set_has_penalty_epsilon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Optimization::clear_has_penalty_epsilon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Optimization::clear_penalty_epsilon() {
  penalty_epsilon_ = 0;
  clear_has_penalty_epsilon();
}
inline float Optimization::penalty_epsilon() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.penalty_epsilon)
  return penalty_epsilon_;
}
inline void Optimization::set_penalty_epsilon(float value) {
  set_has_penalty_epsilon();
  penalty_epsilon_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.penalty_epsilon)
}

// optional float weight_max_vel_x = 6;
inline bool Optimization::has_weight_max_vel_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Optimization::set_has_weight_max_vel_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Optimization::clear_has_weight_max_vel_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Optimization::clear_weight_max_vel_x() {
  weight_max_vel_x_ = 0;
  clear_has_weight_max_vel_x();
}
inline float Optimization::weight_max_vel_x() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_max_vel_x)
  return weight_max_vel_x_;
}
inline void Optimization::set_weight_max_vel_x(float value) {
  set_has_weight_max_vel_x();
  weight_max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_max_vel_x)
}

// optional float weight_max_vel_y = 7;
inline bool Optimization::has_weight_max_vel_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Optimization::set_has_weight_max_vel_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Optimization::clear_has_weight_max_vel_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Optimization::clear_weight_max_vel_y() {
  weight_max_vel_y_ = 0;
  clear_has_weight_max_vel_y();
}
inline float Optimization::weight_max_vel_y() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_max_vel_y)
  return weight_max_vel_y_;
}
inline void Optimization::set_weight_max_vel_y(float value) {
  set_has_weight_max_vel_y();
  weight_max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_max_vel_y)
}

// optional float weight_max_vel_theta = 8;
inline bool Optimization::has_weight_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Optimization::set_has_weight_max_vel_theta() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Optimization::clear_has_weight_max_vel_theta() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Optimization::clear_weight_max_vel_theta() {
  weight_max_vel_theta_ = 0;
  clear_has_weight_max_vel_theta();
}
inline float Optimization::weight_max_vel_theta() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_max_vel_theta)
  return weight_max_vel_theta_;
}
inline void Optimization::set_weight_max_vel_theta(float value) {
  set_has_weight_max_vel_theta();
  weight_max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_max_vel_theta)
}

// optional float weight_acc_lim_x = 9;
inline bool Optimization::has_weight_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Optimization::clear_has_weight_acc_lim_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Optimization::clear_weight_acc_lim_x() {
  weight_acc_lim_x_ = 0;
  clear_has_weight_acc_lim_x();
}
inline float Optimization::weight_acc_lim_x() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_acc_lim_x)
  return weight_acc_lim_x_;
}
inline void Optimization::set_weight_acc_lim_x(float value) {
  set_has_weight_acc_lim_x();
  weight_acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_acc_lim_x)
}

// optional float weight_acc_lim_y = 10;
inline bool Optimization::has_weight_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Optimization::clear_has_weight_acc_lim_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Optimization::clear_weight_acc_lim_y() {
  weight_acc_lim_y_ = 0;
  clear_has_weight_acc_lim_y();
}
inline float Optimization::weight_acc_lim_y() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_acc_lim_y)
  return weight_acc_lim_y_;
}
inline void Optimization::set_weight_acc_lim_y(float value) {
  set_has_weight_acc_lim_y();
  weight_acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_acc_lim_y)
}

// optional float weight_acc_lim_thet = 11;
inline bool Optimization::has_weight_acc_lim_thet() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_thet() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Optimization::clear_has_weight_acc_lim_thet() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Optimization::clear_weight_acc_lim_thet() {
  weight_acc_lim_thet_ = 0;
  clear_has_weight_acc_lim_thet();
}
inline float Optimization::weight_acc_lim_thet() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_acc_lim_thet)
  return weight_acc_lim_thet_;
}
inline void Optimization::set_weight_acc_lim_thet(float value) {
  set_has_weight_acc_lim_thet();
  weight_acc_lim_thet_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_acc_lim_thet)
}

// optional float weight_kinematics_nh = 12;
inline bool Optimization::has_weight_kinematics_nh() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Optimization::set_has_weight_kinematics_nh() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Optimization::clear_has_weight_kinematics_nh() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Optimization::clear_weight_kinematics_nh() {
  weight_kinematics_nh_ = 0;
  clear_has_weight_kinematics_nh();
}
inline float Optimization::weight_kinematics_nh() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_kinematics_nh)
  return weight_kinematics_nh_;
}
inline void Optimization::set_weight_kinematics_nh(float value) {
  set_has_weight_kinematics_nh();
  weight_kinematics_nh_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_kinematics_nh)
}

// optional float weight_kinematics_forward_drive = 13;
inline bool Optimization::has_weight_kinematics_forward_drive() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Optimization::set_has_weight_kinematics_forward_drive() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Optimization::clear_has_weight_kinematics_forward_drive() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Optimization::clear_weight_kinematics_forward_drive() {
  weight_kinematics_forward_drive_ = 0;
  clear_has_weight_kinematics_forward_drive();
}
inline float Optimization::weight_kinematics_forward_drive() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_kinematics_forward_drive)
  return weight_kinematics_forward_drive_;
}
inline void Optimization::set_weight_kinematics_forward_drive(float value) {
  set_has_weight_kinematics_forward_drive();
  weight_kinematics_forward_drive_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_kinematics_forward_drive)
}

// optional float weight_kinematics_turning_radius = 14;
inline bool Optimization::has_weight_kinematics_turning_radius() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Optimization::set_has_weight_kinematics_turning_radius() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Optimization::clear_has_weight_kinematics_turning_radius() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Optimization::clear_weight_kinematics_turning_radius() {
  weight_kinematics_turning_radius_ = 0;
  clear_has_weight_kinematics_turning_radius();
}
inline float Optimization::weight_kinematics_turning_radius() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_kinematics_turning_radius)
  return weight_kinematics_turning_radius_;
}
inline void Optimization::set_weight_kinematics_turning_radius(float value) {
  set_has_weight_kinematics_turning_radius();
  weight_kinematics_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_kinematics_turning_radius)
}

// optional float weight_optimaltime = 15;
inline bool Optimization::has_weight_optimaltime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Optimization::set_has_weight_optimaltime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Optimization::clear_has_weight_optimaltime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Optimization::clear_weight_optimaltime() {
  weight_optimaltime_ = 0;
  clear_has_weight_optimaltime();
}
inline float Optimization::weight_optimaltime() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_optimaltime)
  return weight_optimaltime_;
}
inline void Optimization::set_weight_optimaltime(float value) {
  set_has_weight_optimaltime();
  weight_optimaltime_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_optimaltime)
}

// optional float weight_obstacle = 16;
inline bool Optimization::has_weight_obstacle() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Optimization::set_has_weight_obstacle() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Optimization::clear_has_weight_obstacle() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Optimization::clear_weight_obstacle() {
  weight_obstacle_ = 0;
  clear_has_weight_obstacle();
}
inline float Optimization::weight_obstacle() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_obstacle)
  return weight_obstacle_;
}
inline void Optimization::set_weight_obstacle(float value) {
  set_has_weight_obstacle();
  weight_obstacle_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_obstacle)
}

// optional float weight_inflation = 17;
inline bool Optimization::has_weight_inflation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Optimization::set_has_weight_inflation() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Optimization::clear_has_weight_inflation() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Optimization::clear_weight_inflation() {
  weight_inflation_ = 0;
  clear_has_weight_inflation();
}
inline float Optimization::weight_inflation() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_inflation)
  return weight_inflation_;
}
inline void Optimization::set_weight_inflation(float value) {
  set_has_weight_inflation();
  weight_inflation_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_inflation)
}

// optional float weight_dynamic_obstacle = 18;
inline bool Optimization::has_weight_dynamic_obstacle() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Optimization::set_has_weight_dynamic_obstacle() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Optimization::clear_has_weight_dynamic_obstacle() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Optimization::clear_weight_dynamic_obstacle() {
  weight_dynamic_obstacle_ = 0;
  clear_has_weight_dynamic_obstacle();
}
inline float Optimization::weight_dynamic_obstacle() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_dynamic_obstacle)
  return weight_dynamic_obstacle_;
}
inline void Optimization::set_weight_dynamic_obstacle(float value) {
  set_has_weight_dynamic_obstacle();
  weight_dynamic_obstacle_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_dynamic_obstacle)
}

// optional float weight_viapoint = 19;
inline bool Optimization::has_weight_viapoint() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Optimization::set_has_weight_viapoint() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Optimization::clear_has_weight_viapoint() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Optimization::clear_weight_viapoint() {
  weight_viapoint_ = 0;
  clear_has_weight_viapoint();
}
inline float Optimization::weight_viapoint() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_viapoint)
  return weight_viapoint_;
}
inline void Optimization::set_weight_viapoint(float value) {
  set_has_weight_viapoint();
  weight_viapoint_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_viapoint)
}

// optional float weight_adapt_factor = 20;
inline bool Optimization::has_weight_adapt_factor() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Optimization::set_has_weight_adapt_factor() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Optimization::clear_has_weight_adapt_factor() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Optimization::clear_weight_adapt_factor() {
  weight_adapt_factor_ = 0;
  clear_has_weight_adapt_factor();
}
inline float Optimization::weight_adapt_factor() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_adapt_factor)
  return weight_adapt_factor_;
}
inline void Optimization::set_weight_adapt_factor(float value) {
  set_has_weight_adapt_factor();
  weight_adapt_factor_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_adapt_factor)
}

// optional float weight_prefer_rotdir = 21;
inline bool Optimization::has_weight_prefer_rotdir() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Optimization::set_has_weight_prefer_rotdir() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Optimization::clear_has_weight_prefer_rotdir() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Optimization::clear_weight_prefer_rotdir() {
  weight_prefer_rotdir_ = 0;
  clear_has_weight_prefer_rotdir();
}
inline float Optimization::weight_prefer_rotdir() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_prefer_rotdir)
  return weight_prefer_rotdir_;
}
inline void Optimization::set_weight_prefer_rotdir(float value) {
  set_has_weight_prefer_rotdir();
  weight_prefer_rotdir_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_prefer_rotdir)
}

// optional float weight_acc_lim_theta = 22;
inline bool Optimization::has_weight_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_theta() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Optimization::clear_has_weight_acc_lim_theta() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Optimization::clear_weight_acc_lim_theta() {
  weight_acc_lim_theta_ = 0;
  clear_has_weight_acc_lim_theta();
}
inline float Optimization::weight_acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:or_local_planner.Optimization.weight_acc_lim_theta)
  return weight_acc_lim_theta_;
}
inline void Optimization::set_weight_acc_lim_theta(float value) {
  set_has_weight_acc_lim_theta();
  weight_acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:or_local_planner.Optimization.weight_acc_lim_theta)
}

// -------------------------------------------------------------------

// Config

// optional .or_local_planner.FrameID opt_frame = 1;
inline bool Config::has_opt_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_opt_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_opt_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_opt_frame() {
  if (opt_frame_ != NULL) opt_frame_->::or_local_planner::FrameID::Clear();
  clear_has_opt_frame();
}
inline const ::or_local_planner::FrameID& Config::opt_frame() const {
  const ::or_local_planner::FrameID* p = opt_frame_;
  // @@protoc_insertion_point(field_get:or_local_planner.Config.opt_frame)
  return p != NULL ? *p : *reinterpret_cast<const ::or_local_planner::FrameID*>(
      &::or_local_planner::_FrameID_default_instance_);
}
inline ::or_local_planner::FrameID* Config::mutable_opt_frame() {
  set_has_opt_frame();
  if (opt_frame_ == NULL) {
    opt_frame_ = new ::or_local_planner::FrameID;
  }
  // @@protoc_insertion_point(field_mutable:or_local_planner.Config.opt_frame)
  return opt_frame_;
}
inline ::or_local_planner::FrameID* Config::release_opt_frame() {
  // @@protoc_insertion_point(field_release:or_local_planner.Config.opt_frame)
  clear_has_opt_frame();
  ::or_local_planner::FrameID* temp = opt_frame_;
  opt_frame_ = NULL;
  return temp;
}
inline void Config::set_allocated_opt_frame(::or_local_planner::FrameID* opt_frame) {
  delete opt_frame_;
  opt_frame_ = opt_frame;
  if (opt_frame) {
    set_has_opt_frame();
  } else {
    clear_has_opt_frame();
  }
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.Config.opt_frame)
}

// optional .or_local_planner.Trajectory trajectory_opt = 2;
inline bool Config::has_trajectory_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_trajectory_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_trajectory_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_trajectory_opt() {
  if (trajectory_opt_ != NULL) trajectory_opt_->::or_local_planner::Trajectory::Clear();
  clear_has_trajectory_opt();
}
inline const ::or_local_planner::Trajectory& Config::trajectory_opt() const {
  const ::or_local_planner::Trajectory* p = trajectory_opt_;
  // @@protoc_insertion_point(field_get:or_local_planner.Config.trajectory_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::or_local_planner::Trajectory*>(
      &::or_local_planner::_Trajectory_default_instance_);
}
inline ::or_local_planner::Trajectory* Config::mutable_trajectory_opt() {
  set_has_trajectory_opt();
  if (trajectory_opt_ == NULL) {
    trajectory_opt_ = new ::or_local_planner::Trajectory;
  }
  // @@protoc_insertion_point(field_mutable:or_local_planner.Config.trajectory_opt)
  return trajectory_opt_;
}
inline ::or_local_planner::Trajectory* Config::release_trajectory_opt() {
  // @@protoc_insertion_point(field_release:or_local_planner.Config.trajectory_opt)
  clear_has_trajectory_opt();
  ::or_local_planner::Trajectory* temp = trajectory_opt_;
  trajectory_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_trajectory_opt(::or_local_planner::Trajectory* trajectory_opt) {
  delete trajectory_opt_;
  trajectory_opt_ = trajectory_opt;
  if (trajectory_opt) {
    set_has_trajectory_opt();
  } else {
    clear_has_trajectory_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.Config.trajectory_opt)
}

// optional .or_local_planner.Robot kinematics_opt = 3;
inline bool Config::has_kinematics_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_kinematics_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_kinematics_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_kinematics_opt() {
  if (kinematics_opt_ != NULL) kinematics_opt_->::or_local_planner::Robot::Clear();
  clear_has_kinematics_opt();
}
inline const ::or_local_planner::Robot& Config::kinematics_opt() const {
  const ::or_local_planner::Robot* p = kinematics_opt_;
  // @@protoc_insertion_point(field_get:or_local_planner.Config.kinematics_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::or_local_planner::Robot*>(
      &::or_local_planner::_Robot_default_instance_);
}
inline ::or_local_planner::Robot* Config::mutable_kinematics_opt() {
  set_has_kinematics_opt();
  if (kinematics_opt_ == NULL) {
    kinematics_opt_ = new ::or_local_planner::Robot;
  }
  // @@protoc_insertion_point(field_mutable:or_local_planner.Config.kinematics_opt)
  return kinematics_opt_;
}
inline ::or_local_planner::Robot* Config::release_kinematics_opt() {
  // @@protoc_insertion_point(field_release:or_local_planner.Config.kinematics_opt)
  clear_has_kinematics_opt();
  ::or_local_planner::Robot* temp = kinematics_opt_;
  kinematics_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_kinematics_opt(::or_local_planner::Robot* kinematics_opt) {
  delete kinematics_opt_;
  kinematics_opt_ = kinematics_opt;
  if (kinematics_opt) {
    set_has_kinematics_opt();
  } else {
    clear_has_kinematics_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.Config.kinematics_opt)
}

// optional .or_local_planner.GoalTolerance tolerance_opt = 4;
inline bool Config::has_tolerance_opt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_tolerance_opt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_tolerance_opt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_tolerance_opt() {
  if (tolerance_opt_ != NULL) tolerance_opt_->::or_local_planner::GoalTolerance::Clear();
  clear_has_tolerance_opt();
}
inline const ::or_local_planner::GoalTolerance& Config::tolerance_opt() const {
  const ::or_local_planner::GoalTolerance* p = tolerance_opt_;
  // @@protoc_insertion_point(field_get:or_local_planner.Config.tolerance_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::or_local_planner::GoalTolerance*>(
      &::or_local_planner::_GoalTolerance_default_instance_);
}
inline ::or_local_planner::GoalTolerance* Config::mutable_tolerance_opt() {
  set_has_tolerance_opt();
  if (tolerance_opt_ == NULL) {
    tolerance_opt_ = new ::or_local_planner::GoalTolerance;
  }
  // @@protoc_insertion_point(field_mutable:or_local_planner.Config.tolerance_opt)
  return tolerance_opt_;
}
inline ::or_local_planner::GoalTolerance* Config::release_tolerance_opt() {
  // @@protoc_insertion_point(field_release:or_local_planner.Config.tolerance_opt)
  clear_has_tolerance_opt();
  ::or_local_planner::GoalTolerance* temp = tolerance_opt_;
  tolerance_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_tolerance_opt(::or_local_planner::GoalTolerance* tolerance_opt) {
  delete tolerance_opt_;
  tolerance_opt_ = tolerance_opt;
  if (tolerance_opt) {
    set_has_tolerance_opt();
  } else {
    clear_has_tolerance_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.Config.tolerance_opt)
}

// optional .or_local_planner.Obstacles obstacles_opt = 5;
inline bool Config::has_obstacles_opt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_obstacles_opt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_obstacles_opt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_obstacles_opt() {
  if (obstacles_opt_ != NULL) obstacles_opt_->::or_local_planner::Obstacles::Clear();
  clear_has_obstacles_opt();
}
inline const ::or_local_planner::Obstacles& Config::obstacles_opt() const {
  const ::or_local_planner::Obstacles* p = obstacles_opt_;
  // @@protoc_insertion_point(field_get:or_local_planner.Config.obstacles_opt)
  return p != NULL ? *p : *reinterpret_cast<const ::or_local_planner::Obstacles*>(
      &::or_local_planner::_Obstacles_default_instance_);
}
inline ::or_local_planner::Obstacles* Config::mutable_obstacles_opt() {
  set_has_obstacles_opt();
  if (obstacles_opt_ == NULL) {
    obstacles_opt_ = new ::or_local_planner::Obstacles;
  }
  // @@protoc_insertion_point(field_mutable:or_local_planner.Config.obstacles_opt)
  return obstacles_opt_;
}
inline ::or_local_planner::Obstacles* Config::release_obstacles_opt() {
  // @@protoc_insertion_point(field_release:or_local_planner.Config.obstacles_opt)
  clear_has_obstacles_opt();
  ::or_local_planner::Obstacles* temp = obstacles_opt_;
  obstacles_opt_ = NULL;
  return temp;
}
inline void Config::set_allocated_obstacles_opt(::or_local_planner::Obstacles* obstacles_opt) {
  delete obstacles_opt_;
  obstacles_opt_ = obstacles_opt;
  if (obstacles_opt) {
    set_has_obstacles_opt();
  } else {
    clear_has_obstacles_opt();
  }
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.Config.obstacles_opt)
}

// optional .or_local_planner.Optimization optimize_info = 6;
inline bool Config::has_optimize_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Config::set_has_optimize_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Config::clear_has_optimize_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Config::clear_optimize_info() {
  if (optimize_info_ != NULL) optimize_info_->::or_local_planner::Optimization::Clear();
  clear_has_optimize_info();
}
inline const ::or_local_planner::Optimization& Config::optimize_info() const {
  const ::or_local_planner::Optimization* p = optimize_info_;
  // @@protoc_insertion_point(field_get:or_local_planner.Config.optimize_info)
  return p != NULL ? *p : *reinterpret_cast<const ::or_local_planner::Optimization*>(
      &::or_local_planner::_Optimization_default_instance_);
}
inline ::or_local_planner::Optimization* Config::mutable_optimize_info() {
  set_has_optimize_info();
  if (optimize_info_ == NULL) {
    optimize_info_ = new ::or_local_planner::Optimization;
  }
  // @@protoc_insertion_point(field_mutable:or_local_planner.Config.optimize_info)
  return optimize_info_;
}
inline ::or_local_planner::Optimization* Config::release_optimize_info() {
  // @@protoc_insertion_point(field_release:or_local_planner.Config.optimize_info)
  clear_has_optimize_info();
  ::or_local_planner::Optimization* temp = optimize_info_;
  optimize_info_ = NULL;
  return temp;
}
inline void Config::set_allocated_optimize_info(::or_local_planner::Optimization* optimize_info) {
  delete optimize_info_;
  optimize_info_ = optimize_info;
  if (optimize_info) {
    set_has_optimize_info();
  } else {
    clear_has_optimize_info();
  }
  // @@protoc_insertion_point(field_set_allocated:or_local_planner.Config.optimize_info)
}

// repeated .or_local_planner.FootprintModel robot_type = 7;
inline int Config::robot_type_size() const {
  return robot_type_.size();
}
inline void Config::clear_robot_type() {
  robot_type_.Clear();
}
inline const ::or_local_planner::FootprintModel& Config::robot_type(int index) const {
  // @@protoc_insertion_point(field_get:or_local_planner.Config.robot_type)
  return robot_type_.Get(index);
}
inline ::or_local_planner::FootprintModel* Config::mutable_robot_type(int index) {
  // @@protoc_insertion_point(field_mutable:or_local_planner.Config.robot_type)
  return robot_type_.Mutable(index);
}
inline ::or_local_planner::FootprintModel* Config::add_robot_type() {
  // @@protoc_insertion_point(field_add:or_local_planner.Config.robot_type)
  return robot_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::or_local_planner::FootprintModel >*
Config::mutable_robot_type() {
  // @@protoc_insertion_point(field_mutable_list:or_local_planner.Config.robot_type)
  return &robot_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::or_local_planner::FootprintModel >&
Config::robot_type() const {
  // @@protoc_insertion_point(field_list:or_local_planner.Config.robot_type)
  return robot_type_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace or_local_planner

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::or_local_planner::FootprintModel_FootprintType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::or_local_planner::FootprintModel_FootprintType>() {
  return ::or_local_planner::FootprintModel_FootprintType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_timed_5felastic_5fband_2eproto__INCLUDED
